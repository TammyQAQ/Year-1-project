{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-e0c14763-2d94-4900-b0b4-ba63d78859d6.json","kernel":"python3","kernel_error":"","kernel_state":"busy","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1611765024126,"exec_count":1,"id":"1c4cb5","input":"x = 0\nwhile x < 1000:\n    x = x + 1\n\nprint(\"final value of x: \", x)\n\ny = 0\nwhile y ** 2 < 150:\n    y = y + 1\n\nprint(\"final value of y: \", y)","kernel":"python3","output":{"0":{"name":"stdout","text":"final value of x:  1000\nfinal value of y:  13\n"}},"pos":1,"start":1611765024120,"state":"done","type":"cell"}
{"cell_type":"code","end":1611765098559,"exec_count":2,"id":"278bd9","input":"x = 0\nwhile True:\n    if x ** 2 >= 123456:  # if this condition is true...\n        break             # ...then Python will jump out of the while loop, to the print statement below\n    x = x + 1\n\nprint(x, \" is the smallest number whose square is greater than or equal to 123456\")","kernel":"python3","output":{"0":{"name":"stdout","text":"352  is the smallest number whose square is greater than or equal to 123456\n"}},"pos":3,"start":1611765098553,"state":"done","type":"cell"}
{"cell_type":"code","end":1611789716269,"exec_count":2,"id":"485a1d","input":"n = 198733\nisPrime = True\nfor i in range(2, n):\n    if n % i == 0:        # if n is divisible by i...\n        isPrime = False   # ...then n isn't prime, so set isPrime to False.\nprint(isPrime)","kernel":"python3","output":{"0":{"name":"stdout","text":"True\n"}},"pos":6,"start":1611789716253,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"7649d0","input":"def approx_cube_root(a):\n    x = 1\n    # your code here","pos":9,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"c98e90","input":"n=198733\nis_prime=True\nwhile i<=198733:\n    if n%i==0:\n        is_prime=False\nprint(is_prime)","kernel":"python3","pos":7,"start":1611789731330,"state":"busy","type":"cell"}
{"cell_type":"markdown","id":"061fe9","input":"## Unassessed exercises\n\n### Exercise 1\n\nThis short piece of code checks if a particular whole number `n` (assumed to be larger than 1) is prime or not.  It uses a for loop to test if `n` is divisible by `i` for `i = 2, 3, 4, ..., n-1`.  **Rewrite it so that it uses a while loop instead.**","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"113180","input":"Here are the rules for writing Python while loops: they must look like this.\n\n```\nwhile <condition>:\n    <code to be executed if condition is True>\n```\n`<condition>` must be an expression with a boolean value - true or false. When Python reaches the line beginning `while`, it does the following:\n\n1. it checks if `<condition>` is true or false.  If it is false, it continues with whatever comes after the while loop.\n2. If `<condition>` is true, it executes the indented code which follows the `while` line, called the **body** of the while loop.  Then it goes back to step 1.","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"3909ed","input":"### Exercise 2\n\nThe sequence $(x_n)$ defined by $x_0=1$ and\n\n$$x_{n+1}=\\frac{2x_n^3+a}{3x_n^2}$$\n\nusually converges to $\\sqrt[3]{a}$.\n\nWrite a function `approx_cube_root(a)` which uses a while loop and returns the first term of the sequence $(x_n)$ such that $| x_n^3- a| < 0.001$. The absolute value function in Python is `abs`.\n\nTest your function by checking that `approx_cube_root(a) ** 3` is within 0.001 of `a` for `a=2, 3, 4`","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"742c52","input":"# While loops\n\nA while loop is like a for loop - the same piece of code gets executed again and again - but instead of stopping after a fixed number of times, a while loop keeps going until a certain condition is no longer met.  (In other words, it keeps going *while* the condition is true - hence the name).  After that execution continues with the next line indented the same as the `while` statement.\n\nWhat do you think $x$ and $y$ will be after these while loops run?","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"e5d553","input":"In the first loop the code that gets run again and again is `x = x + 1`, and this keeps running until the condition `x < 1000` is no longer true.  So it stops the first time `x >= 1000`, which is when `x` is equal to 1000.\n\nIn the second loop the code that gets run again and again is `y = y + 1`, and this keeps running until `y ** 2 < 150` is no longer true.  So when it stops, `y` is the smallest whole number whose square is greater than or equal to 150.\n\nThe fact that a while loop can run an unbounded amount of times means that while loops are \"more powerful\" than for loops.  This comes with a drawback: it's easy to write a while loop that will run forever.  For example, if your while loop started `while True:` then the condition would always be true and it seems as if the loop would never stop.\nThere is a way around this: in while loop (or a for loop) you can use the `break` keyword to get out of the loop.  When Python sees `break` it jumps to the next piece of code after the loop.\n\nIf you accidentally make a while loop that will never stop you can use the **Stop** button in the toolbar (next to a black square, between Run and Tab) to stop the computer looping forever.","pos":2,"type":"cell"}
{"id":0,"time":1611789824643,"type":"user"}
{"last_load":1611764425659,"type":"file"}